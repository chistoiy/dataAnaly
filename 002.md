# 开始之路

[toc]

## go的基本编码规范

### 简单的go文件格式

> main.go

````go
package main
//package 为main时，可以被编译成一个可执行的文件，同时要求，必须有一个main函数，无参无返
// package 必须要有

import "fmt"
/*
导包,包名使用引号包裹
只能定义一些变量声明，标识符，类型，常量，函数
不可书写逻辑操作
*/
func main(){ //左大括号不支持占一行
    fmt.Println("Hello world!")//换行
    fmt.Printf("string values is : %s", s1) //占位符
    fmt.Print("print one")
}
````



当使用换源后，即使用了 go env -w GO111MODULE=on

``go build``  会失败，

因为换源所开启的go env -w GO111MODULE=on，使得go默认管理依赖的方式变成了go module模式，即依赖一个go.mod文件，其中描述了项目依赖的包和版本（类似于npm package.json，maven的pom.xml）

而目录中没有go.mod文件，所以go不知道主模块是什么，所以无法编译

```
go mod init hello //hello为主 go文件名即可
```

选择目录》终端中运行》go build

![1593701765351](./002.assets/1593701765351.png)

出现main.exe,终端运行main.exe即可

### 关键字

```go
break default func interface select
case defer go map struct
chan else goto package switch
const fallthrough if range type
continue for import return var
```



### 保留字

```go
Constants: 
		true false iota nil

Types:
		int int8 int16 int32 int64
		uint uint8 uint16 uint32 uint64 uintptr
		float32 float64 complex128 complex64
		bool byte rune string error

Functions: 
		make len cap new append copy close delete
		complex real imag
		painc recover
```



### 变量

go中变量名均需要事先声明类型后，才可以使用，同一作用域不支持重复定义

#### 变量的定义

+ var 变量名 类型 

```go
var n1 int
var s1 string
var s2  string = "st"
var ( //批量声明变量，可以在函数内，也可以在函数外部
    n3 int
    s3 string
)
var s4,s5 string = "q", "t"
var s6 = "w" //编译时会自动根据右边值来推测类型
s7 := "p" //简短声明，省略了var，同时根据值来推测类型，但只能用于函数之中
_, x := foo() // 匿名变量，当一个函数返回多个值，但只使用其中部分，则可以以_来接收，起到占位、忽略作用
```

**tips**：

+ 声明的变量必须被使用，否则不允许编译

  ```
  .\main.go:14:3: xx declared but not used
  ```

+ 如果声明变量，但是没有赋值，则默认为其默认的值，int类型为0，bool类型为false，string类型为“”

+ 推荐使用小驼峰命名

### 格式化go编码

```shell
go fmt main.go // 文件名
```

### 常量

+ 以const定义，类似var声明，但是声明时，必须初始化，同时不可被修改

```go
const c1 = 123
const c2 = "qwe"
const (
	c3 = 456
    c4 = "asd"
    c5  //此时，与c4保持一致
    c6  // 与c5，c5一致
)

```

+ iota

iota在同一个const出现时被重置，同时，每声明一次常量，均会被累加一（即中间常量未继续赋值未iota，iota也会被加1）, 枚举时，可使用

```go
const(
	n1 = iota
    n2
)
const(
	n3 = iota
    n4
)

const(
	n5 = iota  //0
    _  //1
    n6 //2
)

const(
	n7 = iota  //0
    n8 = 100   //100
    n9 = iota  //2
)

fmt.Println("iota:", n1, n2)

fmt.Println("iota:", n3, n4)
```

```
iota: 0 1
iota: 0 1
```



**tips**

+ 如果批量定义常量，某一个未定义值，则跟随上一个常量